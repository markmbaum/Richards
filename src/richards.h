#ifndef RICHARDS_H_
#define RICHARDS_H_

//! \file richards.h
/*!
\mainpage Richards

This is a model for solving the richards equation for unsaturated groundwater flow in one dimension. For background information on the equations used here, please see Chapter 7, Section 4 of [Margulis, S. "Introduction To Hydrology." Used as textbook in C&EE 150 (2014).](https://margulis-group.github.io/teaching/)
+ The model uses a nonuniform, finite-volume grid. The surface cell is the smallest, with larger cells at depth.
+ The particular ratio of cell depths can be controlled and a maximum cell depth can be set.
+ The model is set up to use a fully saturated bottom boundary and a top boundary that goes through cycles of full saturation and full dryness. The cycle is meant to simulate periodic wetting events and the amount of water that penetrates to the bottom boundary for different cycle properties and physical parameters.
+ There are three different `main` programs that generate three different executables.
    1. `main.cc` is compiled into `richards.exe`, which integrates the model without any cycling. This program is most useful for testing. The `scripts/plot_out.py` program plots the results generated by theis program.
    2. `main_periodic.cc` is compiled into `richards_periodic.exe`, which spins up the model with cyclical surface wetting, then integrates over a single cycle and writes results. The `scripts/plot_period.py` script is meant to plot the results of this program.
    3. `main_periodic_batch.cc` is compiled into `richards_periodic_batch.exe`, and this program is more involved. It sweeps over ranges of parameters, spinning up and integrating the model for all possible combinations of these parameters. It writes the results of a single cycle for all the combinations. Integrations are performed in parallel, on however many threads you have available. Some of the settins in the input settings file are overridden inside the program.

The first two programs require two input arguments at the command line:
1. the path of a settings file
2. the path of an output directory

The third program requires three command line arguments:
1. the path of a settings file
2. the domain depth
3. the path of an output directory

What is a settings file? An example should be included in the repository as `settings.txt`. This file is the means by which the model is configured. Each program reads and parses the file for information about how to set up the grid, physical parameters, integration settings, and output options. Browse that sample file for a complete list of the settings. The final section of that file, "tracker and output settings", controls which model variables are written to file as part of the model output.

To compile the model, edit the first four variables in the Makefile, then run `make`. The model runs on top of ODE solvers from [libode](https://github.com/wordsworthgroup/libode), which must be downloaded and compiled first.

After things are compiled, a quick test would consist of:
\code{sh}
./bin/richards_periodic.exe settings.txt out
cd scripts
python plot_period.py
cd ..
\endcode
*/

#include <cmath>
#include <cstdio>
#include <string>
#include <vector>
#include <iostream>

#include "io.h"
#include "grid.h"
#include "util.h"
#include "settings.h"

//header file for ODE integrator class
#include "ode_ssp_3.h"

//!the main model class
class Richards : public OdeSsp3 {

public:

    //!constructs
    /*!
    \param[in] grid a Grid object defining the model domain and discretization
    \param[in] stgin a Settings object defining model settings and configuration
    */
    Richards (Grid grid, Settings stgin);

    //!settings container
    Settings stg;

    //--------------
    //grid variables

    //!number of cells
    const long n;
    //!length/depth of domain (m)
    const double dep;
    //!cell edge coordinates (m)
    const std::vector<double> ze;
    //!cell center coordinates (m)
    const std::vector<double> zc;
    //!cell width (m)
    const std::vector<double> delz;
    //!cell widths used for stability calculations (m)
    const std::vector<double> delze;
    //!factors for cell edge values
    const std::vector<double> vefac;
    //!factors for cell edge gradients
    const std::vector<double> gefac;
    //!constants for finding maximum stable time step
    std::vector<double> dtcons;

    //------------------
    //physical variables

    //static depth-varying quantities

    //!porosity at cell centers (maximum saturation fraction)
    std::vector<double> poroc;
    //!porosity at cell edges
    std::vector<double> poroe;
    //!saturated hydraulic conductivity over depth (m/s)
    std::vector<double> Ksat;
    //!saturated matric head (m)
    std::vector<double> psisat;

    //dynamic, depth-varying quantities

    //!water fractions at cell edges
    std::vector<double> we;
    //!derivative of psi w/r/t moisture
    std::vector<double> dpsidw;
    //!derivative of moisture w/r/t z
    std::vector<double> dwdz;
    //!hydraulic conductivity (unsaturated)
    std::vector<double> K;
    //!diffusivity (K*d psi /dt)
    std::vector<double> D;
    //!fluxes
    std::vector<double> q;

    //--------
    //trackers

    //!time tracker
    std::vector<float> t;
    //!snapshot times
    std::vector<float> tsnap;
    //!top boundary flux
    std::vector<float> qtop;
    //!middle boundary flux
    std::vector<float> qmid;
    //!index of approximate middle edge
    unsigned long mididx;
    //!bottom boundary flux
    std::vector<float> qbot;
    //!whether to track ALL fluxes
    std::vector< std::vector<float> > qall;
    //!whether to track ALL water fractions
    std::vector< std::vector<float> > wall;
    //!infiltration flag
    std::vector<float> infil;

    //------------------
    //physical functions

    //!computes porosity as a function of depth (-)
    double f_poro (double depth, double poro);

    //!computes saturated permeability (m^2)
    double f_ksat (double depth, double perm);

    //!computes saturated hydraulic conductivity (m/s)
    double f_Ksat (double depth, double g, double mu, double rho);

    //!computes Brooks-Corey hydraulic conductivity (m/s)
    double f_K (double w, double Ksat, double wsat, double b);

    //!computes the saturation matric head (m)
    double f_psisat (double depth);

    //!computes derivative of Brooks-Corey matric head w/r/t water fraction (-)
    double f_dpsidw (double w, double psisat, double wsat, double b);

    //!infiltration flag
    bool f_infil (double t);

    //!bottom boundary condition
    double f_w_bot (double poro);

    //--------------------
    //ODE solver functions

    //!computes beginning and end of next or current infiltration event
    void infil_times (double t, double *ta, double *tb);

    //!computes the flux between two cells
    double f_q (double K, double dpsidw, double dwdz, double satl, double satr);

    //!computes the time derivative of a cell, given fluxes on its sides
    double f_dwdt (double qt, double qb, double delz);

    //!updates fluxes
    void update_q (double *w, double t);

    //!ode function for the integrator
    void ode_fun (double *solin, double *fout);

    //!computes the next time step, based on the maximum diffusivity
    double dt_adapt ();

    //!integrates to steady state using current state boundary conditions
    void steady (double atol=1e-9, unsigned long ntol=1000000);

    //!integrates over infiltration periods until nearly periodic behavior is established
    void spinup (double rtol=1e-12, bool quiet=true);

    //-----------------
    //extras

    //!does extra stuff before starting a solve
    void before_solve ();
    //!does extra stuff after every snap
    void after_snap (std::string dirout, long isnap, double t);
    //!updates fluxes and sets a flag, if needed
    void q_updated (double t, bool *qup);
    //!does extra stuff after every step
    void after_step (double tin);
    //!does extra stuff after integrating
    void after_solve ();

};

#endif
